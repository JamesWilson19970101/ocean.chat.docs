"use strict";(self.webpackChunkoceanchat_devdocs=self.webpackChunkoceanchat_devdocs||[]).push([[3384],{8133:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"devdocs/microservice","title":"Microservice Architecture","description":"The entire platform is divided into four logical layers, containing 10 core microservices and 1 data processing pipeline, ensuring a clear separation of responsibilities.","source":"@site/docs/devdocs/microservice.md","sourceDirName":"devdocs","slug":"/devdocs/microservice","permalink":"/ocean.chat.docs/docs/devdocs/microservice","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"graphql vs http in oceanchat","permalink":"/ocean.chat.docs/docs/devdocs/graphql vs http in oceanchat"}}');var t=n(4848),r=n(8453);const a={},o="Microservice Architecture",l={},c=[{value:"IM Architecture Diagram",id:"im-architecture-diagram",level:2},{value:"Layer 1: Gateway and Access Layer",id:"layer-1-gateway-and-access-layer",level:2},{value:"<strong>1. Connection Gateway Service (Stateful)</strong>",id:"1-connection-gateway-service-stateful",level:3},{value:"<strong>2. Message Routing Service (Stateless)</strong>",id:"2-message-routing-service-stateless",level:3},{value:"Layer 2: Core Business Logic Layer",id:"layer-2-core-business-logic-layer",level:2},{value:"<strong>3. User &amp; Relationship Service (Stateless)</strong>",id:"3-user--relationship-service-stateless",level:3},{value:"<strong>4. Group Service (Stateless)</strong>",id:"4-group-service-stateless",level:3},{value:"<strong>5. Message Logic Service (Stateless)</strong>",id:"5-message-logic-service-stateless",level:3},{value:"Layer 3: Message Push Pipeline",id:"layer-3-message-push-pipeline",level:2},{value:"<strong>6. Push Orchestration Service (Stateless)</strong>",id:"6-push-orchestration-service-stateless",level:3},{value:"<strong>7. Real-time Push Worker (Stateless)</strong>",id:"7-real-time-push-worker-stateless",level:3},{value:"<strong>8. Offline Push Worker (Stateless)</strong>",id:"8-offline-push-worker-stateless",level:3},{value:"Layer 4: Foundational Support Services",id:"layer-4-foundational-support-services",level:2},{value:"<strong>9. Online Status Service (Stateless)</strong>",id:"9-online-status-service-stateless",level:3},{value:"<strong>10. Data Query Service (Stateless)</strong>",id:"10-data-query-service-stateless",level:3},{value:"Data Processing Pipeline: Message Persistence",id:"data-processing-pipeline-message-persistence",level:3},{value:"Demo Flow",id:"demo-flow",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"microservice-architecture",children:"Microservice Architecture"})}),"\n",(0,t.jsx)(s.p,{children:"The entire platform is divided into four logical layers, containing 10 core microservices and 1 data processing pipeline, ensuring a clear separation of responsibilities."}),"\n",(0,t.jsx)(s.h2,{id:"im-architecture-diagram",children:"IM Architecture Diagram"}),"\n",(0,t.jsx)(s.p,{children:"// TODO: Diagram"}),"\n",(0,t.jsx)(s.h2,{id:"layer-1-gateway-and-access-layer",children:"Layer 1: Gateway and Access Layer"}),"\n",(0,t.jsx)(s.p,{children:"This layer is the direct entry point for users, focusing on handling massive concurrent connections, and is the performance bottleneck of the entire system."}),"\n",(0,t.jsx)(s.h3,{id:"1-connection-gateway-service-stateful",children:(0,t.jsx)(s.strong,{children:"1. Connection Gateway Service (Stateful)"})}),"\n",(0,t.jsx)(s.p,{children:"Given that this service is stateful, the design aims to keep it as business-agnostic, lightweight, and simple as possible."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Protocol Handling"}),": Maintain client WebSocket/TCP long-lived connections, handle heartbeats, connection establishment, and disconnection."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Data Passthrough"}),": Acts as a pure connection channel. It does not process any business logic, only encapsulates the client's raw data packets (e.g., by adding metadata like ",(0,t.jsx)(s.code,{children:"connectionId"}),", ",(0,t.jsx)(s.code,{children:"gatewayId"}),') and then quickly delivers them to the backend "Message Routing Service".']}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Client Message Delivery"}),': Receives instructions from the "Real-time Push Worker" and accurately pushes messages to clients connected to this instance.']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),": To completely separate the most resource-intensive I/O tasks (maintaining connections) from CPU-intensive tasks (business logic). This allows the Connection Gateway to be highly optimized and scaled horizontally independently to support tens or even hundreds of millions of concurrent connections."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"2-message-routing-service-stateless",children:(0,t.jsx)(s.strong,{children:"2. Message Routing Service (Stateless)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Message Decoding and Dispatching"}),': Receives raw data packets from the "Connection Gateway", mimics the DDP protocol for decoding, protocol parsing, and initial validation.']}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Business Routing"}),": Determines which business microservice should handle the message based on its type or command, then dispatches it to the corresponding business service via the NATS message queue."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Upstream Traffic Control"}),': Implements generic rate limiting and circuit breaking. For example, limiting "each user ID to forward a maximum of 100 requests per second to the backend". However, specific business logic, like the high frequency of sending normal messages (e.g., 10 per second) versus the low frequency of creating a group (e.g., once per minute), or dependency-based circuit breaking protection, should be implemented in the specific services.']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),": To decouple the access layer from the business logic layer. The routing service acts as a middle coordinator, making the addition, removal, and changes of backend business services completely transparent to the gateway layer, greatly improving system flexibility and maintainability."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"layer-2-core-business-logic-layer",children:"Layer 2: Core Business Logic Layer"}),"\n",(0,t.jsx)(s.p,{children:"This layer is responsible for handling all core business functions of the IM platform. It is designed as a stateless service for easy horizontal scaling."}),"\n",(0,t.jsx)(s.h3,{id:"3-user--relationship-service-stateless",children:(0,t.jsx)(s.strong,{children:"3. User & Relationship Service (Stateless)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),": Manages user accounts, profiles, friend relationships (add/delete/blacklist), contacts, etc."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),": User and relationship data are fundamental to an IM system. Isolating them provides a unified and stable data source for other services."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"4-group-service-stateless",children:(0,t.jsx)(s.strong,{children:"4. Group Service (Stateless)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),": Responsible for the full lifecycle management of groups, including group creation/disbandment, member management, permission systems, group announcements, group settings, and all group-related functions."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),": The business logic for group chats (especially permissions and member management) is very complex. Separating it into a service helps reduce code complexity and facilitates independent development and iteration."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"5-message-logic-service-stateless",children:(0,t.jsx)(s.strong,{children:"5. Message Logic Service (Stateless)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Message Processing"}),": This is the business processing center for one-on-one and group chat messages. It's responsible for permission checks (e.g., is the user a friend, are they in the group?), content processing (@mentions, sensitive word filtering), generating message IDs, and assembling the message body."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Triggering Delivery"}),': After message processing is complete, it calls the "Push Orchestration Service" to start the message delivery process.']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),': To separate the business logic of the message itself ("what it is") from the message delivery process ("how it\'s sent"), making responsibilities clearer.']}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"layer-3-message-push-pipeline",children:"Layer 3: Message Push Pipeline"}),"\n",(0,t.jsx)(s.p,{children:"This is the key to ensuring reliable and real-time message delivery, and it is a highly asynchronous processing flow."}),"\n",(0,t.jsx)(s.h3,{id:"6-push-orchestration-service-stateless",children:(0,t.jsx)(s.strong,{children:"6. Push Orchestration Service (Stateless)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Message-to-Delivery Decision"}),': Receives messages to be delivered from the "Message Logic Service".']}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Status Query"}),': Queries the "Online Status Service" in real-time to get the online status and gateway node of all recipients.']}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Task Dispatch"}),': Based on the online status, splits the message into "online push tasks" and "offline push tasks" and atomically writes these tasks to different Kafka message queues.']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),': As the "brain" of message delivery, it handles complex decision-making logic. Isolating it makes the push process clearer and easier to monitor and debug.']}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"7-real-time-push-worker-stateless",children:(0,t.jsx)(s.strong,{children:"7. Real-time Push Worker (Stateless)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),': Listens to the "online push" queue, consumes tasks, and then communicates directly with the "Connection Gateway" instance where the target user is connected, instructing it to deliver the message.']}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),": Dedicated to handling online message pushes, it can be scaled independently based on the number of online users and message volume to ensure real-time performance."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Tech Stack"}),": Kafka consumer, ioredis (for inter-gateway Pub/Sub)."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"8-offline-push-worker-stateless",children:(0,t.jsx)(s.strong,{children:"8. Offline Push Worker (Stateless)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),': Listens to the "offline push" queue, consumes tasks, and then calls Apple APNS, Google FCM, or domestic vendor push APIs to send offline notifications.']}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),": Integration with third-party APIs often involves network latency and uncertainty. Isolating it prevents its failures or slowness from affecting the core real-time push pipeline."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"layer-4-foundational-support-services",children:"Layer 4: Foundational Support Services"}),"\n",(0,t.jsx)(s.p,{children:"These services provide stable and efficient foundational capabilities for the entire platform."}),"\n",(0,t.jsx)(s.h3,{id:"9-online-status-service-stateless",children:(0,t.jsx)(s.strong,{children:"9. Online Status Service (Stateless)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),":","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Status Maintenance"}),": Maintains the global online status of users in real-time through a ",(0,t.jsx)(s.code,{children:"userId -> {gatewayId, status}"})," mapping."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Status Query"}),': Provides millisecond-level online status query interfaces for services like the "Push Orchestration Service".']}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),": Online status is the cornerstone of a distributed IM system, with extremely high read and write frequency. An independent service using an in-memory database like Redis allows for extreme optimization to ensure high performance."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"10-data-query-service-stateless",children:(0,t.jsx)(s.strong,{children:"10. Data Query Service (Stateless)"})}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),":","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Unified Query Entrypoint"}),": Provides a unified HTTP API for clients to query historical messages, conversation lists, etc."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Tiered Query"}),": Intelligently pulls and aggregates data from different storage media (Redis cache, MongoDB etc.) based on the query's time range."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),": Implements read-write separation. Separating high-frequency read operations from the core write pipeline allows for independent optimization of query performance without affecting the stability of message writing."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"data-processing-pipeline-message-persistence",children:"Data Processing Pipeline: Message Persistence"}),"\n",(0,t.jsx)(s.p,{children:"This is not a service, but an asynchronous processing flow."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Core Responsibilities"}),': After the "Message Logic Service" processes a message, in addition to calling the push service, it also sends a copy of the message to a dedicated persistence message queue (like Kafka). One or more independent ',(0,t.jsx)(s.strong,{children:"consumer processes (Writers)"})," listen to this queue and batch-write the messages to the database."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Reason for Separation"}),': Complete asynchronicity. Sending and receiving messages should not wait for the database write to complete. This "write-after-persistence" design maximizes message real-time performance.']}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"demo-flow",children:"Demo Flow"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"User A sends a message to Group G:"}),"\n",(0,t.jsx)(s.li,{children:"Client A -> Connection Gateway-1 (establishes connection)"}),"\n",(0,t.jsx)(s.li,{children:"Connection Gateway-1 -> Message Routing Service (passthrough)"}),"\n",(0,t.jsx)(s.li,{children:"Message Routing Service -> Message Logic Service (routing)"}),"\n",(0,t.jsxs)(s.li,{children:["Message Logic Service processes the message (validates permissions, generates ID), then forks into two paths:","\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"-> Push Orchestration Service (initiates delivery)"}),"\n",(0,t.jsx)(s.li,{children:"-> Kafka persistence queue (prepares for storage)"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.li,{children:"Push Orchestration Service queries the Online Status Service, learns that group member B is online (on Gateway-2) and C is offline."}),"\n",(0,t.jsx)(s.li,{children:'Push Orchestration Service -> sends a task for B to the "online push queue" and a task for C to the "offline push queue".'}),"\n",(0,t.jsx)(s.li,{children:"Real-time Push Worker consumes task B -> instructs Connection Gateway-2 -> Client B receives the message."}),"\n",(0,t.jsx)(s.li,{children:"Offline Push Worker consumes task C -> calls APNS/FCM API -> Client C receives a notification."}),"\n",(0,t.jsx)(s.li,{children:"A Persistence Writer consumes the message from Kafka -> writes it to MongoDB."}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>o});var i=n(6540);const t={},r=i.createContext(t);function a(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);