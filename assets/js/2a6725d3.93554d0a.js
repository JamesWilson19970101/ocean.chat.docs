"use strict";(self.webpackChunkoceanchat_devdocs=self.webpackChunkoceanchat_devdocs||[]).push([[3969],{3831:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"devdocs/JWT","title":"JWT Hybrid Authentication","description":"In modern web applications and microservices architectures, authentication is the cornerstone of the security system. JWT (JSON Web Token) based authentication is widely adopted due to its stateless, scalable, and cross-domain-friendly features. However, a single, long-lived JWT token has inherent risks in terms of security and flexibility.","source":"@site/docs/devdocs/JWT.md","sourceDirName":"devdocs","slug":"/devdocs/JWT","permalink":"/ocean.chat.docs/docs/devdocs/JWT","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Budiness Logic","permalink":"/ocean.chat.docs/docs/devdocs/Budiness Logic"},"next":{"title":"cache issues","permalink":"/ocean.chat.docs/docs/devdocs/cache"}}');var t=n(4848),r=n(8453);const o={},c="JWT Hybrid Authentication",l={},d=[{value:"Access Token (AT)",id:"access-token-at",level:2},{value:"Refresh Token (RT)",id:"refresh-token-rt",level:2},{value:"Hybrid Mode",id:"hybrid-mode",level:2},{value:"Security Strategy",id:"security-strategy",level:2},{value:"Secure Token Generation &amp; Configuration",id:"secure-token-generation--configuration",level:3},{value:"Secure Client-Side Storage",id:"secure-client-side-storage",level:3},{value:"Access Token",id:"access-token",level:4},{value:"Refresh Token",id:"refresh-token",level:4},{value:"Secure Token Transmission",id:"secure-token-transmission",level:3},{value:"Secure Token Rotation &amp; Validation",id:"secure-token-rotation--validation",level:3},{value:"Secure Session Termination",id:"secure-session-termination",level:3},{value:"Workflow",id:"workflow",level:2},{value:"Step 1: Initial Login",id:"step-1-initial-login",level:4},{value:"Step 2: Accessing Protected Resources",id:"step-2-accessing-protected-resources",level:4},{value:"Step 3: Access Token Expiration &amp; Refresh",id:"step-3-access-token-expiration--refresh",level:4},{value:"Step 4: Logout",id:"step-4-logout",level:4}];function a(e){const s={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"jwt-hybrid-authentication",children:"JWT Hybrid Authentication"})}),"\n",(0,t.jsx)(s.p,{children:"In modern web applications and microservices architectures, authentication is the cornerstone of the security system. JWT (JSON Web Token) based authentication is widely adopted due to its stateless, scalable, and cross-domain-friendly features. However, a single, long-lived JWT token has inherent risks in terms of security and flexibility."}),"\n",(0,t.jsx)(s.admonition,{title:"Core Idea",type:"tip",children:(0,t.jsxs)(s.p,{children:["This platform adopts a ",(0,t.jsx)(s.strong,{children:"JWT Hybrid Mode Authentication Strategy"}),". This strategy combines the use of a short-lived ",(0,t.jsx)(s.code,{children:"Access Token"})," and a long-lived ",(0,t.jsx)(s.code,{children:"Refresh Token"}),", implementing defense-in-depth at every stage to achieve the best balance between high performance, high security, and excellent user experience."]})}),"\n",(0,t.jsx)(s.h2,{id:"access-token-at",children:"Access Token (AT)"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Role"}),': The "pass" for clients to access protected resources. It is a high-frequency use token.']}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Characteristics"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Short-lived"}),": The validity period is extremely short, planned to be ",(0,t.jsx)(s.strong,{children:"5 to 15 minutes"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Stateless Validation"}),": The server only needs to verify its signature and expiration to trust its content, without querying the database. This ensures extremely high processing performance."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Risk"}),": Due to its high frequency of use and transmission, the risk of theft is relatively high. Its short lifespan is key to mitigating this risk."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Payload"}),": Contains non-sensitive user identity information, such as user ID, roles, etc., following the principle of least privilege."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"refresh-token-rt",children:"Refresh Token (RT)"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Role"}),': The sole credential for obtaining a new Access Token. It can be seen as the "session key" that maintains the user\'s login state. It is a low-frequency use token.']}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Characteristics"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Long-lived"}),": The validity period is longer, planned to be ",(0,t.jsx)(s.strong,{children:"7 to 30 days"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Stateful Validation"}),": When processing an RT, the server must query the database or cache to verify if it is still valid. This provides the ability to revoke sessions."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Risk"}),": Once leaked, it can lead to severe security consequences. Therefore, it must be protected with the strictest storage and transmission measures."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"hybrid-mode",children:"Hybrid Mode"}),"\n",(0,t.jsx)(s.p,{children:"The core idea of this mode is to separate authentication responsibilities:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Daily Access (99% of scenarios)"}),": Use stateless, high-performance Access Tokens."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Session Renewal (1% of scenarios)"}),": Use stateful, high-security Refresh Tokens."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"This design allows the system to respond quickly in most cases while retaining the ability to perform strict security checks at critical moments (like session refresh, logout)."}),"\n",(0,t.jsx)(s.h2,{id:"security-strategy",children:"Security Strategy"}),"\n",(0,t.jsx)(s.h3,{id:"secure-token-generation--configuration",children:"Secure Token Generation & Configuration"}),"\n",(0,t.jsx)(s.admonition,{title:"Isolate Secrets",type:"danger",children:(0,t.jsxs)(s.p,{children:["The Access Token and Refresh Token ",(0,t.jsx)(s.strong,{children:"must"})," be signed with two completely different and sufficiently complex secrets (",(0,t.jsx)(s.code,{children:"JWT_ACCESS_SECRET"})," and ",(0,t.jsx)(s.code,{children:"JWT_REFRESH_SECRET"}),") to prevent one from being inferred from the other."]})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Minimize Payload"}),": The Access Token payload ",(0,t.jsx)(s.strong,{children:"must not"})," contain any sensitive information (such as passwords, phone numbers, detailed permissions, etc.). It should only contain necessary identifiers (like ",(0,t.jsx)(s.code,{children:"userId"}),") and roles."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Reasonable Expiration"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["AT: ",(0,t.jsx)(s.code,{children:"15m"})," (15 minutes)."]}),"\n",(0,t.jsxs)(s.li,{children:["RT: ",(0,t.jsx)(s.code,{children:"7d"})," (7 days)."]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"secure-client-side-storage",children:"Secure Client-Side Storage"}),"\n",(0,t.jsx)(s.h4,{id:"access-token",children:"Access Token"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Preferred: Store in JavaScript memory variables"}),". This is the most secure method as it does not persist between browser sessions and is completely immune to CSRF attacks."]}),"\n",(0,t.jsx)(s.admonition,{title:"Advantages",type:"tip",children:(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Extremely High Security"}),": This is the best way to defend against XSS (Cross-Site Scripting) attacks. Because the token is stored in a JavaScript variable, even if an attacker can inject a script, they cannot directly and persistently read it like they could with ",(0,t.jsx)(s.code,{children:"sessionStorage"})," or ",(0,t.jsx)(s.code,{children:"localStorage"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"No CSRF Risk"}),": Since the token needs to be manually added to the ",(0,t.jsx)(s.code,{children:"Authorization"})," request header via JavaScript, the browser does not automatically include it, making it completely immune to CSRF (Cross-Site Request Forgery) attacks."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Minimal Attack Window"}),": Once the user closes the tab or refreshes the page, the memory variable is cleared, and the token disappears immediately. This means even if the token is stolen at some point, its lifespan is extremely short."]}),"\n"]})}),"\n",(0,t.jsx)(s.admonition,{title:"Disadvantages",type:"caution",children:(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Poor User Experience"}),": This is the biggest drawback. Every time a user refreshes the page or opens a new tab to access your application, the Access Token in memory is lost. This forces the application to immediately use the Refresh Token to get a new Access Token, increasing the frequency of requests to the ",(0,t.jsx)(s.code,{children:"/refresh"}),' endpoint. If the network is poor, the user may feel a noticeable "reload" or "lag".']}),"\n"]})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsxs)(s.strong,{children:["Secondary: Store in ",(0,t.jsx)(s.code,{children:"sessionStorage"})]}),". It persists on page refresh but is cleared when the browser window is closed."]}),"\n",(0,t.jsx)(s.admonition,{title:"Advantages",type:"tip",children:(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Better User Experience"}),": It can persist within a single tab's session. After a user refreshes the page, the token is still valid, and the application can immediately restore its state without needing to request a new token."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Isolation"}),": ",(0,t.jsx)(s.code,{children:"sessionStorage"})," is tab-based. The data is cleared when the tab is closed and is not stored permanently like ",(0,t.jsx)(s.code,{children:"localStorage"}),"."]}),"\n"]})}),"\n",(0,t.jsx)(s.admonition,{title:"Disadvantages",type:"caution",children:(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Vulnerable to XSS"}),": This is its biggest security vulnerability compared to in-memory storage. If your site has an XSS vulnerability, an attacker's injected script can easily read the token via ",(0,t.jsx)(s.code,{children:"sessionStorage.getItem('accessToken')"})," and send it to their own server."]}),"\n"]})}),"\n",(0,t.jsx)(s.h4,{id:"refresh-token",children:"Refresh Token"}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsxs)(s.strong,{children:["Store in an ",(0,t.jsx)(s.code,{children:"HttpOnly"})," browser Cookie."]})}),"\n",(0,t.jsx)(s.admonition,{title:"Cookie Attributes",type:"info",children:(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"HttpOnly"}),": This flag prevents any client-side JavaScript from accessing the cookie, fundamentally stopping XSS attacks from stealing the RT."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Secure"}),": This flag forces the browser to only send the cookie over HTTPS connections."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"SameSite=Strict"})," or ",(0,t.jsx)(s.code,{children:"Lax"}),": This flag helps defend against CSRF (Cross-Site Request Forgery) attacks."]}),"\n"]})}),"\n",(0,t.jsx)(s.h3,{id:"secure-token-transmission",children:"Secure Token Transmission"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Enforce HTTPS"}),": All authentication-related endpoints, and the entire application, ",(0,t.jsx)(s.strong,{children:"must"})," be forced to use HTTPS (TLS) encryption. This prevents tokens from being intercepted by Man-in-the-Middle (MITM) attacks during transmission."]}),"\n",(0,t.jsx)(s.h3,{id:"secure-token-rotation--validation",children:"Secure Token Rotation & Validation"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Refresh Token Rotation"}),": This is the core mechanism for detecting RT theft."]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["When a client uses an RT (",(0,t.jsx)(s.code,{children:"RT_A"}),") to refresh, the server, upon successful validation, returns both a new AT (",(0,t.jsx)(s.code,{children:"AT_B"}),") and a brand new RT (",(0,t.jsx)(s.code,{children:"RT_B"}),")."]}),"\n",(0,t.jsxs)(s.li,{children:["The server immediately marks the old ",(0,t.jsx)(s.code,{children:"RT_A"})," as used or invalid."]}),"\n"]}),"\n",(0,t.jsx)(s.admonition,{title:"Replay Attack Detected",type:"danger",children:(0,t.jsxs)(s.p,{children:["If the server later receives another refresh request with ",(0,t.jsx)(s.code,{children:"RT_A"}),", it means the token may have been stolen (an attacker is replaying the old token). In this case, the server should immediately invalidate all sessions for that user, forcing them to re-login on all devices."]})}),"\n",(0,t.jsx)(s.h3,{id:"secure-session-termination",children:"Secure Session Termination"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"User Logout"}),": When a user logs out, the client should actively request the ",(0,t.jsx)(s.code,{children:"/logout"})," endpoint. Upon receiving the request, the server must clear the corresponding RT hash stored in the database, thus invalidating the RT immediately."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Force Logout from All Devices"}),': Provide a "Security Settings" option that allows the user to clear all RT records associated with their account, achieving a one-click sign-out.']}),"\n",(0,t.jsx)(s.h2,{id:"workflow",children:"Workflow"}),"\n",(0,t.jsx)(s.h4,{id:"step-1-initial-login",children:"Step 1: Initial Login"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Client"}),": User enters username and password on the login page and clicks login."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Server"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"Validate the credentials."}),"\n",(0,t.jsxs)(s.li,{children:["If correct, generate a pair of tokens:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["A short-lived Access Token (",(0,t.jsx)(s.code,{children:"AT_A"}),")."]}),"\n",(0,t.jsxs)(s.li,{children:["A long-lived Refresh Token (",(0,t.jsx)(s.code,{children:"RT_A"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["Hash ",(0,t.jsx)(s.code,{children:"RT_A"})," and store the hash (",(0,t.jsx)(s.code,{children:"Hashed_RT_A"}),") in the corresponding user record in the database."]}),"\n",(0,t.jsxs)(s.li,{children:["Send the tokens back to the client via HTTP response:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"AT_A"})," is placed in the response body (JSON Body)."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"RT_A"})," is placed in a ",(0,t.jsx)(s.code,{children:"Set-Cookie"})," response header with the ",(0,t.jsx)(s.code,{children:"HttpOnly; Secure; SameSite=Strict"})," flags."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"step-2-accessing-protected-resources",children:"Step 2: Accessing Protected Resources"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Client"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Stores ",(0,t.jsx)(s.code,{children:"AT_A"})," from the response body in memory."]}),"\n",(0,t.jsxs)(s.li,{children:["Includes ",(0,t.jsx)(s.code,{children:"AT_A"})," in the ",(0,t.jsx)(s.code,{children:"Authorization: Bearer <AT_A>"})," header for every request to a protected API."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Server"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Receives the request and extracts ",(0,t.jsx)(s.code,{children:"AT_A"}),"."]}),"\n",(0,t.jsx)(s.li,{children:"Performs a quick, stateless validation (checks signature and expiration)."}),"\n",(0,t.jsx)(s.li,{children:"If valid, processes the request and returns data."}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"step-3-access-token-expiration--refresh",children:"Step 3: Access Token Expiration & Refresh"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Client"}),": Makes an API request with an expired ",(0,t.jsx)(s.code,{children:"AT_A"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Server"}),": Validates ",(0,t.jsx)(s.code,{children:"AT_A"}),", finds it has expired, rejects the request, and returns a ",(0,t.jsx)(s.code,{children:"401 Unauthorized"})," status code."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Client (Request Interceptor)"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Automatically catches the ",(0,t.jsx)(s.code,{children:"401"})," error."]}),"\n",(0,t.jsxs)(s.li,{children:["Automatically sends a request to the server's ",(0,t.jsx)(s.code,{children:"/auth/refresh"})," endpoint(server response should include path). The browser will automatically include the ",(0,t.jsx)(s.code,{children:"RT_A"})," stored in the ",(0,t.jsx)(s.code,{children:"HttpOnly"})," cookie."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsxs)(s.strong,{children:["Server (",(0,t.jsx)(s.code,{children:"/auth/refresh"})," endpoint)"]}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Gets ",(0,t.jsx)(s.code,{children:"RT_A"})," from the cookie."]}),"\n",(0,t.jsxs)(s.li,{children:["Performs ",(0,t.jsx)(s.strong,{children:"stateful validation"}),":","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Checks the signature and expiration of ",(0,t.jsx)(s.code,{children:"RT_A"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["Extracts ",(0,t.jsx)(s.code,{children:"userId"})," from the ",(0,t.jsx)(s.code,{children:"RT_A"})," payload."]}),"\n",(0,t.jsxs)(s.li,{children:["Queries the database using ",(0,t.jsx)(s.code,{children:"userId"})," to get the stored ",(0,t.jsx)(s.code,{children:"Hashed_RT_A"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["Compares the hash of the received ",(0,t.jsx)(s.code,{children:"RT_A"})," with ",(0,t.jsx)(s.code,{children:"Hashed_RT_A"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Validation Succeeded (Token Rotation)"}),":","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Generate a brand new pair of tokens: ",(0,t.jsx)(s.code,{children:"AT_B"})," and ",(0,t.jsx)(s.code,{children:"RT_B"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["Hash ",(0,t.jsx)(s.code,{children:"RT_B"})," and use the new ",(0,t.jsx)(s.code,{children:"Hashed_RT_B"})," to overwrite ",(0,t.jsx)(s.code,{children:"Hashed_RT_A"})," in the database."]}),"\n",(0,t.jsxs)(s.li,{children:["Return ",(0,t.jsx)(s.code,{children:"AT_B"})," and the new ",(0,t.jsx)(s.code,{children:"RT_B"})," (via ",(0,t.jsx)(s.code,{children:"HttpOnly"})," cookie) to the client."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Validation Failed"}),": Return ",(0,t.jsx)(s.code,{children:"403 Forbidden"}),", indicating an invalid session."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Client (Request Interceptor)"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Upon receiving the new ",(0,t.jsx)(s.code,{children:"AT_B"}),", updates the Access Token in memory."]}),"\n",(0,t.jsxs)(s.li,{children:["Automatically retries the API request that just failed with a ",(0,t.jsx)(s.code,{children:"401"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["If a ",(0,t.jsx)(s.code,{children:"403"})," is received, clears all local state and redirects the user to the login page."]}),"\n"]}),"\n",(0,t.jsx)(s.h4,{id:"step-4-logout",children:"Step 4: Logout"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Client"}),": User clicks the logout button, sending a request to the ",(0,t.jsx)(s.code,{children:"/auth/logout"})," endpoint."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Server"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"Identifies the user via the Access Token."}),"\n",(0,t.jsxs)(s.li,{children:["Finds the user's record in the database and sets their ",(0,t.jsx)(s.code,{children:"hashedRefreshToken"})," field to ",(0,t.jsx)(s.code,{children:"null"}),"."]}),"\n",(0,t.jsxs)(s.li,{children:["Sends a ",(0,t.jsx)(s.code,{children:"Set-Cookie"})," header in the response to clear the ",(0,t.jsx)(s.code,{children:"HttpOnly"})," cookie."]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>c});var i=n(6540);const t={},r=i.createContext(t);function o(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);