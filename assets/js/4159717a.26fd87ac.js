"use strict";(self.webpackChunkoceanchat_devdocs=self.webpackChunkoceanchat_devdocs||[]).push([[1456],{5148:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"devdocs/Authorization","title":"Permission System Design Considerations","description":"For permission design, I am not adopting a separate, centralized permission service. Instead, I follow a more pragmatic design principle: The sole owner of the data is the sole party responsible for permission decisions (Policy Decision Point, PDP).","source":"@site/docs/devdocs/Authorization.md","sourceDirName":"devdocs","slug":"/devdocs/Authorization","permalink":"/ocean.chat.docs/docs/devdocs/Authorization","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Auth Service","permalink":"/ocean.chat.docs/docs/devdocs/Auth Service"},"next":{"title":"Budiness Logic","permalink":"/ocean.chat.docs/docs/devdocs/Budiness Logic"}}');var r=n(4848),t=n(8453);const o={},a="Permission System Design Considerations",c={},l=[{value:"Approach 1: A Centralized, Independent Permission Service",id:"approach-1-a-centralized-independent-permission-service",level:2},{value:"The Practical Challenges of a Centralized Permission Service",id:"the-practical-challenges-of-a-centralized-permission-service",level:2},{value:"1. Network Overhead and Performance Bottlenecks",id:"1-network-overhead-and-performance-bottlenecks",level:3},{value:"2. Data Dependency and Service Coupling",id:"2-data-dependency-and-service-coupling",level:3},{value:"My Design: Decentralized Decisions",id:"my-design-decentralized-decisions",level:2},{value:"1. Decentralizing the Decision Logic",id:"1-decentralizing-the-decision-logic",level:3},{value:"2. Centralizing Permission Metadata",id:"2-centralizing-permission-metadata",level:3}];function d(e){const i={admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"permission-system-design-considerations",children:"Permission System Design Considerations"})}),"\n",(0,r.jsx)(i.admonition,{title:"Core Principle: Whoever Owns the Data, Makes the Decision",type:"tip",children:(0,r.jsxs)(i.p,{children:["For permission design, I am not adopting a separate, centralized permission service. Instead, I follow a more pragmatic design principle: ",(0,r.jsx)(i.strong,{children:"The sole owner of the data is the sole party responsible for permission decisions (Policy Decision Point, PDP)"}),"."]})}),"\n",(0,r.jsx)(i.h2,{id:"approach-1-a-centralized-independent-permission-service",children:"Approach 1: A Centralized, Independent Permission Service"}),"\n",(0,r.jsx)(i.p,{children:'A common approach is to extract permission logic (e.g., "determine if Role A has Permission X") into an independent oceanchat-permission service. In theory, this approach has several advantages:'}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Highly Centralized Logic:"})," All permission rules are concentrated in one place, making it very simple to modify and audit policies."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Decoupling of Business Services:"}),' The MessageService or GroupService no longer needs to care about complex permission logic. They only need to ask the permission service, "Can User U perform Action A on Resource R?" and then proceed based on the "yes/no" answer, leading to cleaner business code.']}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Single Responsibility:"})," The permission service only makes authorization decisions, giving it a very pure responsibility."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"the-practical-challenges-of-a-centralized-permission-service",children:"The Practical Challenges of a Centralized Permission Service"}),"\n",(0,r.jsx)(i.p,{children:"Although the model of an independent permission service is elegant in theory, it faces two major challenges in practice, especially in a system like oceanchat that requires a large amount of contextual data for decision-making."}),"\n",(0,r.jsx)(i.h3,{id:"1-network-overhead-and-performance-bottlenecks",children:"1. Network Overhead and Performance Bottlenecks"}),"\n",(0,r.jsx)(i.p,{children:"Treating a permission check as a network call (RPC/HTTP) significantly increases request latency. More critically, the permission service becomes a key single point of failure for the entire system. If it fails or its performance degrades, all services that rely on it for permission checks (especially write operations) could be blocked."}),"\n",(0,r.jsx)(i.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant MessageService\n    participant PermissionService\n    participant GroupService\n    Client->>MessageService: Request: Send Message\n    MessageService->>PermissionService: Query: Has permission?\n    PermissionService->>GroupService: Query: Need decision data (e.g., members, mute status)\n    GroupService--\x3e>PermissionService: Reply: Return data\n    PermissionService--\x3e>MessageService: Reply: Has permission\n    MessageService->>Client: Response: Message sent successfully"}),"\n",(0,r.jsx)(i.p,{children:"The diagram above shows that a simple request to send a message results in multiple internal network communications because of the introduction of a centralized permission service."}),"\n",(0,r.jsx)(i.h3,{id:"2-data-dependency-and-service-coupling",children:"2. Data Dependency and Service Coupling"}),"\n",(0,r.jsx)(i.p,{children:"Permission decisions are often not stateless; they are highly dependent on specific business data."}),"\n",(0,r.jsxs)(i.blockquote,{children:["\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Scenario 1: Can User A send a message in Group G?"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Data Needed:"}),' Is A a member of Group G? Has A been muted? Is Group G currently in a "mute-all" state?']}),"\n",(0,r.jsxs)(i.li,{children:["*",(0,r.jsx)(i.em,{children:"Data Owner:"})," All of this data is stored in the database of the Group Service (oceanchat-group)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.blockquote,{children:["\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Scenario 2: Can User A remove their friendship with User B?"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Data Needed:"})," Are A and B friends?"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Data Owner:"})," This data is stored in the database of the User Relationship Service (oceanchat-user)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"For an independent permission service to make these decisions, it only has two options, both of which have serious flaws:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Option A: Reverse-Calling Data Services"}),"\nTo make a decision, the permission service needs to call back to the GroupService and UserRelationshipService to fetch the required data. This leads to a complex and fragile service call chain (e.g., MessageService -> PermissionService -> GroupService), which not only increases latency but also raises the risk of circular dependencies in the system."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Option B: Synchronizing Data to the Permission Service"}),"\nThe permission service maintains its own copy of the data required for decisions (such as group memberships, friend relationships, etc.). This introduces extremely high complexity related to data synchronization and eventual consistency."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"my-design-decentralized-decisions",children:"My Design: Decentralized Decisions"}),"\n",(0,r.jsxs)(i.p,{children:["Based on the challenges above, I decided to adopt a more pragmatic and efficient model: ",(0,r.jsx)(i.strong,{children:"let the service that owns the data become the Policy Decision Point itself."}),"\u3002"]}),"\n",(0,r.jsx)(i.p,{children:"This means that the logic for permission checks will be tightly co-located with the data it depends on."}),"\n",(0,r.jsx)(i.p,{children:"Here is the implementation plan:"}),"\n",(0,r.jsx)(i.h3,{id:"1-decentralizing-the-decision-logic",children:"1. Decentralizing the Decision Logic"}),"\n",(0,r.jsx)(i.p,{children:"Delegate the responsibility for permission decisions to the services that own the relevant data."}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Group-related Permissions:"})," All permission-checking logic related to groups (e.g., sending messages, inviting members, muting) is encapsulated within the GroupService. When the MessageService needs to check a user's permissions in a group, it directly calls an interface provided by the GroupService, such as groupService.checkPermission(userId, groupId, 'SEND_MESSAGE')."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"User Relationship Permissions:"})," Similarly, permission checks for adding/removing friends are handled by the UserRelationshipService."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"The advantages of this model are clear:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"High Performance:"})," Permission decisions are made within the same service that holds the required data, avoiding extra network overhead."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"High Cohesion:"})," The data and the logic that uses it are encapsulated together, which aligns with good software design principles."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"High Availability:"})," It eliminates the single point of failure risk associated with a centralized permission service."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"2-centralizing-permission-metadata",children:"2. Centralizing Permission Metadata"}),"\n",(0,r.jsx)(i.p,{children:'Although the decision logic is decentralized, the "definitions" of permissions must be centralized and consistent.'}),"\n",(0,r.jsx)(i.p,{children:'I will create a shared internal library (e.g., common-defs) where all platform-wide "Roles" and "Permission" identifiers are uniformly defined using Enums or Constants.'}),"\n",(0,r.jsx)(i.p,{children:"For example:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-typescript",children:'// In the shared library common-defs\nexport enum GroupPermission {\n  SEND_MESSAGE = "group:send_message",\n  INVITE_USER = "group:invite_user",\n  // ... other permissions\n}\n'})}),"\n",(0,r.jsx)(i.p,{children:"All services will depend on this shared library to reference permission definitions, ensuring that the entire system has a consistent understanding of what each permission means."})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var s=n(6540);const r={},t=s.createContext(r);function o(e){const i=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);