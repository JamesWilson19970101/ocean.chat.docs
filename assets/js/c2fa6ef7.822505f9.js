"use strict";(self.webpackChunkoceanchat_devdocs=self.webpackChunkoceanchat_devdocs||[]).push([[1653],{1590:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"devdocs/ADR - Architecture Decision Records/Consistency And Performance TRADE-OFF In Authentication","title":"Consistency vs. Performance Trade-off in Authentication","description":"Background & Problem","source":"@site/docs/devdocs/ADR - Architecture Decision Records/Consistency And Performance TRADE-OFF In Authentication.md","sourceDirName":"devdocs/ADR - Architecture Decision Records","slug":"/devdocs/ADR - Architecture Decision Records/Consistency And Performance TRADE-OFF In Authentication","permalink":"/ocean.chat.docs/docs/devdocs/ADR - Architecture Decision Records/Consistency And Performance TRADE-OFF In Authentication","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"oceanchat - devdocs","permalink":"/ocean.chat.docs/docs/category/oceanchat---devdocs"},"next":{"title":"Auth Service","permalink":"/ocean.chat.docs/docs/devdocs/Auth Service"}}');var i=t(4848),o=t(8453);const r={},c="Consistency vs. Performance Trade-off in Authentication",a={},l=[{value:"Background &amp; Problem",id:"background--problem",level:2},{value:"Login Flow",id:"login-flow",level:3},{value:"Decision",id:"decision",level:2},{value:"Final Solution Logic",id:"final-solution-logic",level:2},{value:"Trade-off Analysis",id:"trade-off-analysis",level:2},{value:"Why not use the &quot;Local Message Table (Outbox Pattern)&quot;?",id:"why-not-use-the-local-message-table-outbox-pattern",level:3},{value:"Why is the current solution acceptable?",id:"why-is-the-current-solution-acceptable",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"consistency-vs-performance-trade-off-in-authentication",children:"Consistency vs. Performance Trade-off in Authentication"})}),"\n",(0,i.jsx)(n.h2,{id:"background--problem",children:"Background & Problem"}),"\n",(0,i.jsx)(n.h3,{id:"login-flow",children:"Login Flow"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Client"})," submits credentials (username/password)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Auth Service"})," verifies credentials and generates a JWT."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consistency Assurance Steps"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Step A (Sync)"}),": Write the JWT to the Redis whitelist (set TTL). If this fails, throw an error immediately."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Step B (Sync)"}),": Publish the ",(0,i.jsx)(n.code,{children:"auth.event.user.loggedIn"})," event to NATS JetStream and wait for an Acknowledgement (Ack)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Exception Handling"}),": If the Redis write succeeds but the NATS publish fails, immediately delete the Token from Redis (",(0,i.jsx)(n.strong,{children:"Rollback"}),") and return an error to the client."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Return the JWT to the client."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When the ",(0,i.jsx)(n.code,{children:"oceanchat-auth"})," service processes user logins, it involves write operations to two heterogeneous systems:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Redis"}),": Writes to the JWT whitelist (Synchronous, used for Gateway authentication)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"NATS JetStream"}),": Publishes the ",(0,i.jsx)(n.code,{children:"user.loggedIn"})," event (Asynchronous logic, used for downstream status/database updates)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Core Conflict"}),': Redis and NATS cannot share an atomic transaction. If the Redis write succeeds but the NATS publish fails, it leads to the existence of a "Zombie Token," resulting in system inconsistency.']}),"\n",(0,i.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsxs)(n.p,{children:["We have decided to adopt the lightweight strategy of ",(0,i.jsx)(n.strong,{children:'"Failure Rollback + TTL"'}),", ",(0,i.jsx)(n.strong,{children:"abandoning"})," the heavyweight Local Message Table (Transactional Outbox) pattern."]}),"\n",(0,i.jsx)(n.h2,{id:"final-solution-logic",children:"Final Solution Logic"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Generate JWT."}),"\n",(0,i.jsx)(n.li,{children:"Write to Redis (Default TTL = 7 days)."}),"\n",(0,i.jsx)(n.li,{children:"Synchronously publish the NATS message and wait for Ack."}),"\n",(0,i.jsxs)(n.li,{children:["If NATS fails -> Catch Exception -> ",(0,i.jsx)(n.strong,{children:"Immediately delete the Redis Key"})," -> Return login failure to the frontend."]}),"\n",(0,i.jsx)(n.li,{children:"If the Rollback (deletion) also fails -> Accept the risk (rely on Redis TTL for automatic expiration as a safety net)."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"trade-off-analysis",children:"Trade-off Analysis"}),"\n",(0,i.jsx)(n.h3,{id:"why-not-use-the-local-message-table-outbox-pattern",children:'Why not use the "Local Message Table (Outbox Pattern)"?'}),"\n",(0,i.jsx)(n.p,{children:"Although the MongoDB Transaction + Outbox pattern guarantees 100% eventual consistency, it has the following drawbacks:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Overhead"}),": Login is a high-frequency and latency-sensitive operation. Introducing database transactions increases latency."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Architectural Complexity"}),": It requires maintaining additional Worker processes and compensation logic."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Low ROI (Return on Investment)"}),": Unlike financial transactions which require absolute rigor, login failures allow users to retry manually."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"why-is-the-current-solution-acceptable",children:"Why is the current solution acceptable?"}),"\n",(0,i.jsx)(n.p,{children:"Even in extreme cases (Redis write succeeds -> NATS fails -> Service crashes preventing rollback):"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consequence"}),": An invalid Token remains in Redis, which will automatically disappear after 7 days."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Impact"}),": The user experiences a login failure, but the system recovers to a normal state upon a simple retry. Business data remains uncorrupted, and the security risk is negligible."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var s=t(6540);const i={},o=s.createContext(i);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);