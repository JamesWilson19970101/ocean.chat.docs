# 性能和数据一致性的权衡（登录流程）

## 背景与问题

### 登录流程

1. 客户端提交账号密码。
2. Auth 服务 验证通过，生成 JWT。
3. 一致性保障步骤:
    - 步骤 A (同步): 将 JWT 写入 Redis 白名单 (设置 TTL)。若失败，直接报错。
    - 步骤 B (同步): 向 NATS JetStream 发布 auth.event.user.loggedIn 事件，并等待 Ack。
    - 异常处理: 若 Redis 写入成功但 NATS 发布失败，立即删除 Redis 中的 Token (回滚)，并向客户端返回错误。
4. 返回 JWT 给客户端。

在 `oceanchat-auth` 服务处理用户登录时，需要涉及两个异构系统的写操作：
1. **Redis**: 写入 JWT 白名单（同步，供网关鉴权）。
2. **NATS JetStream**: 发布 `user.loggedIn` 事件（异步，供下游更新状态/数据库）。

**核心冲突**：Redis 和 NATS 无法共享原子事务。若 Redis 写入成功但 NATS 发布失败，会导致“僵尸 Token”存在，系统状态不一致。

## 决策 (Decision)

我决定采用 **“失败回滚 + 短 TTL”** 的轻量级策略，**放弃**重量级的本地消息表事务方案。

## 最终方案逻辑

1. 生成 JWT。
2. 写入 Redis（默认 TTL = 7天）。
3. 同步发布 NATS 消息并等待 Ack。
4. 若 NATS 失败 -> 捕获异常 -> **立即删除 Redis Key** -> 返回前端登录失败。
5. 若回滚（删除）也失败 -> 接受该风险（依靠 Redis TTL 自动兜底）。

## 权衡分析

### 为什么不使用“本地消息表 (Outbox Pattern)”？

虽然 MongoDB 事务 + Outbox 模式能保证 100% 最终一致性，但存在以下缺点：
- **性能损耗**：登录是高频且敏感操作，引入 DB 事务会增加延迟。
- **架构复杂度**：需要维护额外的 Worker 进程和补偿逻辑。
- **投入产出比低**：登录失败允许用户重试，不需要像金融交易那样绝对严谨。

### 为什么当前方案是可接受的？

即使发生极端情况（Redis 写成功 -> NATS 失败 -> 服务宕机无法回滚）：
- **后果**：Redis 中残留一个无效 Token，7 天后自动消失。
- **影响**：用户端表现为登录失败，用户重试即可恢复正常。业务数据不会产生错乱，安全性风险极低。