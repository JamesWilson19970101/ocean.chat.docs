import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# 缓存

在构建高性能、高可用的后端服务时，缓存是不可或缺的一环。它能显著降低数据库的访问压力，加快数据响应速度。本文将探讨系统设计中采用的多级缓存架构、缓存策略以及应对经典缓存问题的解决方案。

## 多级缓存

系统采用 **本地内存缓存 (L1) + 分布式缓存 (L2)** 的多级缓存架构，以应对不同的访问需求。

:::info 典型应用场景：用户在线状态

用户在线状态的读写极为频繁，是多级缓存的最佳应用场景。

- **L1 (本地内存缓存)**: 每台 IM 服务器都在自己的内存中缓存当前连接到本机的所有用户的状态和路由信息。这提供了毫秒级的访问速度，用于处理本机内的消息转发和状态查询。
- **L2 (Redis 分布式缓存)**: Redis 中存储了全网所有在线用户的状态和路由信息。当发生跨服务器的通信时，如果 L1 缓存未命中，则会查询 L2 缓存。

:::

## 缓存策略

### 读操作 (Cache-Aside Pattern)

1.  应用先从 **Redis** 获取数据。
2.  如果 Redis 中有数据（**缓存命中**），则直接返回。
3.  如果 Redis 中没有数据（**缓存未命中**），则从 **MongoDB** 查询。
4.  将从 MongoDB 查到的数据写入 Redis（并设置合理的过期时间），然后返回给应用。

:::tip 优点
逻辑简单，实现方便。并且这是一种“懒加载”模式，只有被实际请求的数据才会被缓存，有效节约了缓存空间。
:::

:::caution 缺点
对于首次请求的数据，会经历一次缓存未命中的开销（一次 Redis 访问 + 一次 DB 访问），导致响应时间稍长。
:::

### 写操作

当数据发生变更时（如管理员修改了某项配置），必须保证缓存与数据库的一致性。

<Tabs>
<TabItem value="a" label="方案 A: 先更新数据库，再删除缓存 (推荐)" default>

1.  服务收到更新请求。
2.  将新值写入 **MongoDB**。
3.  成功后，向 Redis 发送 `DEL` 命令，**删除**对应的缓存键。

**优点**:
- 简单可靠，是业界的标准实践之一。
- 下次读取该数据时，会发生一次缓存未命中，然后自动从数据库加载最新值并回填缓存，保证了最终一致性。

**缺点**:
- 如果删除缓存失败，数据库是新的，缓存是旧的，会导致短时间的数据不一致（直到缓存过期）。但这属于小概率事件，可以通过重试机制等方式缓解。

</TabItem>
<TabItem value="b" label="方案 B: 先删除缓存，再更新数据库">

1.  服务收到更新请求。
2.  向 Redis 发送 `DEL` 命令，**删除**对应的缓存键。
3.  将新值写入 **MongoDB**。

:::danger 存在严重 BUG
在高并发场景下，此方案可能导致数据库与缓存的**数据永久不一致**（直到缓存过期）。

**时序问题**:
1. 请求 A 发起更新操作，先删除了 Redis 缓存。
2. 此时，请求 B 发起读操作，发现 Redis 缓存不存在。
3. 请求 B 从数据库读取了**旧值**，并将其写入 Redis。
4. 请求 A 完成数据库的更新操作。

最终结果：数据库中是新值，但 Redis 缓存中却是旧值，且这个旧值会一直存在，直到它自然过期。
:::

</TabItem>
</Tabs>

## 经典问题

### 缓存穿透

**现象**：恶意或意外地大量请求一个数据库中**根本不存在**的 Key。由于缓存中也没有，所有请求都会直接打到数据库上，可能导致数据库崩溃。

:::tip 解决方案: 缓存空值 (Cache Nulls)
当从数据库查询一个不存在的 Key 时，也在 Redis 中为这个 Key 缓存一个特殊的“空值”（比如一个约定的字符串 `"NULL"`），并设置一个较短的过期时间（如 1-5 分钟）。这样，后续对这个不存在的 Key 的请求就会命中“空值缓存”，直接返回，从而保护数据库。
:::

### 缓存击穿

**现象**: 某一个**热点 Key**（例如一个访问频率极高的设置）突然过期了。在这一瞬间，海量的并发请求会同时涌入，发现缓存未命中，然后全部去请求数据库，导致数据库压力剧增。

:::tip 解决方案: 使用分布式锁
1. 当发生缓存未命中时，不是所有请求都去查数据库。
2. 只有一个请求能获取到一个基于 Redis 的分布式锁（例如使用 `SET key value NX PX milliseconds` 命令）。
3. 这个请求负责去数据库查询数据并回填缓存，然后释放锁。
4. 其他未获取到锁的请求，则稍等片刻后重试（此时大概率能从缓存中获取到数据了）。
:::

### 缓存雪崩

**现象**: **大量的 Key 在同一时间集体失效**（例如，服务重启后所有缓存的过期时间都设置成一样的），导致所有请求都瞬间打到数据库上。

:::tip 解决方案: 过期时间加随机值
在设置基础过期时间的同时，给它增加一个小的随机数。例如，不要把所有 Key 的 TTL 都设为 60 分钟，而是设为 `60分钟 + (0-5分钟内的一个随机值)`。这样可以把过期时间打散，避免集中失效。
:::

### 缓存预热

:::info 概念：缓存预热 (Cache Warm-up)
当服务（尤其是在微服务架构中新启动的实例）刚启动时，Redis 缓存是空的。如果此时有大量请求涌入，这些请求都会穿透缓存直接访问数据库，给数据库带来巨大压力，这也被称为“冷启动”问题。缓存预热就是在服务启动阶段，提前将热点数据或全量基础数据加载到缓存中。
:::

### 缓存降级

:::caution 概念：缓存降级 (Cache Degrade)
在分布式系统中，任何外部依赖（如 Redis）都可能出现故障。如果 Redis 服务不可用，而我们的代码逻辑强依赖于它，那么整个功能甚至依赖它的其他服务都会崩溃。缓存降级是一种容错机制：当缓存服务异常时，系统可以降级为直接读写数据库，保证核心功能的可用性，只是性能有所下降。
:::
