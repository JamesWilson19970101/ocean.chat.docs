# 消息队列

本文主要对比三种消息队列中间件（RocketMQ vs Kafka vs NATS），并解释为什么选择 NATS 作为 Ocean Chat 的中间件。

## 核心架构和设计理念

- Apache RocketMQ
    - 设计哲学：诞生于阿里电商业务，强调消息的“绝对不丢失”和复杂的业务处理能力。它更像是一个功能完善的业务系统组件，而非单纯的数据管道。
    - 通信模型：采用 Topic + Queue 模式。消费者订阅 Topic，实际上是拉取 Queue 中的数据。支持 Tag 二级过滤，适合业务隔离。
    - 架构依赖：依赖 NameServer 进行服务发现。NameServer 虽然比 Zookeeper 轻量且去中心化，但仍需独立部署和维护，增加了运维组件数量。
    - 技术栈：纯 Java 实现，生态成熟但运行时较重。
- Apache Kafka
    - 设计哲学：设计初衷是处理海量日志和流数据。它本质上是一个分布式的、可分区的、多副本的提交日志服务（Commit Log），核心目标是极限吞吐量。
    - 通信模型：采用 Topic + Partition 模式。严格的分区有序性，消费者组与分区绑定。
    - 架构依赖：长期依赖 Zookeeper 管理元数据（新版 KRaft 模式虽移除了 ZK，但配置参数依然极其复杂，调优难度大）。
    - 技术栈：Scala 和 Java 混合编写，严重依赖操作系统的 PageCache。
- NATS (Core & JetStream)
    - 设计哲学：推崇极简主义。Core NATS 负责极速的即时通信（Fire-and-forget），JetStream 负责持久化流处理。它的目标是成为云原生时代的“中枢神经系统”。
    - 通信模型：采用 Subject-based (主题式) 寻址。不局限于固定的 Topic，而是支持动态的 . 分层结构和通配符（*, >），比传统的 Topic/Queue 模型灵活得多。
    - 架构依赖：零依赖。它是一个静态编译的 Go 语言二进制文件（Single Binary），内置 Raft 共识算法，无需任何外部组件即可组建全网状集群。
    - 技术栈：Go 语言编写，云原生友好。

## 功能

- Apache RocketMQ
    - 消息类型：原生支持事务消息（分布式事务利器）、延迟消息（定时任务）、顺序消息、死信队列和重试队列。
    - 过滤能力：支持 Tag 过滤和 SQL 92 标准属性过滤，可以在服务端过滤掉不需要的消息，减少网络带宽压力。
    - 交互模式：虽然支持 Request-Reply，但本质上还是基于异步消息模拟的，实现较重。
- Apache Kafka
    - 消息类型：功能相对基础，主要依赖其强大的流处理生态（Kafka Streams, KSQL）。不支持原生的任意时间延迟消息。
    - 交互模式：仅支持异步解耦。完全不适合用于同步的 RPC 调用场景。
    - 过滤能力：较弱，通常需要消费者将所有数据拉取到本地后再进行过滤。
- NATS
    - 消息类型：JetStream 支持消息去重、持久化流。虽然没有原生的“事务消息”，但支持 Headers 和延迟发布。
    - 交互模式：原生支持 Request-Reply。这是 NATS 的杀手级特性，使它能直接替代 HTTP/gRPC 进行微服务内部的同步调用，性能极高。
    - 独有特性：内置 KV Store（分布式键值存储）和 Object Store（对象存储），支持多租户（Accounts）隔离，支持 WebSocket。

## 性能

- Apache RocketMQ
    - 吞吐量：高（10万+ TPS）。虽不如 Kafka 的极限吞吐，但足以支撑大规模电商并发。
    - 延迟：低且稳定（ms 级）。针对在线业务优化，即使在消息堆积的情况下，延迟波动也较小，不会像 Kafka 那样出现明显的长尾延迟。
    - 资源消耗：高。作为 Java 应用，堆内存（Heap）开销大，垃圾回收（GC）可能导致瞬时的性能“毛刺”。
- Apache Kafka
    - 吞吐量：极高（百万级 TPS）。通过磁盘顺序读写和零拷贝（Zero Copy）技术，实现了惊人的写入性能，非常适合日志收集。
    - 延迟：中等（ms ~ 几十 ms）。为了追求高吞吐，Kafka 默认采用微批处理（Batching）机制，导致单条消息的实时性不如 NATS 和 RocketMQ。
    - 资源消耗：高。需要大量的内存用于 PageCache 缓存日志段，且对磁盘 I/O 占用较高。
- NATS
    - 吞吐量：极高。Core NATS 可达千万级 TPS；JetStream 在开启持久化模式下，吞吐量接近 Kafka，但 CPU 效率更高。
    - 延迟：极低（μs ~ ms 级）。由于代码路径极短且没有 JVM 的负担，NATS 提供了几乎是市面上最低的端到端延迟，非常适合高频交易和 IoT 控制指令。
    - 资源消耗：极低。Docker 镜像仅 ~15MB，启动仅需几 MB 内存，极大节省云服务器成本。

## 为什么选择 NATS？

- 轻量级
    - RocketMQ/Kafka 的负担：RocketMQ 和 Kafka 都是基于 JVM 的“重型”中间件。运维它们需要懂 JVM 调优（堆大小、GC 策略），需要部署配套组件（RocketMQ 的 NameServer，Kafka 的 ZK/KRaft），且镜像体积动辄几百 MB。
    - NATS 的优势：NATS 是一个静态编译的 Go 二进制文件。
        - 部署：docker run nats 即可，镜像 < 20MB。
        - 运维：没有 JVM GC 停顿问题，没有外部依赖，配置文件极简。
        - 集群：节点间自动发现（Gossip），全网状连接，扩容极其简单。

- 架构统一
    - RocketMQ/Kafka：主要解决的是“异步解耦”和“削峰填谷”。如果还需要服务间同步调用，通常还需要引入 gRPC 或 Dubbo。
    - NATS：一套系统搞定所有通信。
        - 即时通讯：Core NATS 的 Pub/Sub。
        - RPC 调用：原生 Request-Reply 模式，性能极高，可直接替代 gRPC。
        - 持久化存储：JetStream 替代 Kafka/RocketMQ。
        - KV 存储：内置分布式 KV 和对象存储，甚至可以替代部分 Redis 用法。
        - 结论：选择 NATS 可以让技术栈减少 2-3 个组件。

- 实用主义

    - 性能“够用”：

        虽然 Kafka 的极限吞吐量（百万级 TPS）更高，但对于 99% 的企业级应用，这属于严重的性能过剩。NATS 单节点轻松支撑数万甚至十万级 TPS，这已经远超大多数业务的峰值需求。相比于 Kafka 追求极限吞吐而牺牲的实时性，NATS 的低延迟特性在日常业务中带来的体验提升更加直观和重要。
    
    - 功能“够用”：
    
        RocketMQ 确实拥有事务消息、定时消息等高级特性，但在微服务实践中，往往可以通过架构设计（如本地消息表、独立调度服务）来解决这些问题。NATS 提供的核心功能（持久化、ACK 确认、重试机制、流控）已经覆盖了分布式通信 95% 的核心需求。为了剩下 5% 极少用到的特定功能，去引入并维护一套庞大且复杂的 RocketMQ/Kafka 集群，从投入产出比（ROI）来看往往并不划算。NATS 以最小的运维成本解决了最核心的问题。