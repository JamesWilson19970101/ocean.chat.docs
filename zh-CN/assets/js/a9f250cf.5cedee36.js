"use strict";(self.webpackChunkoceanchat_devdocs=self.webpackChunkoceanchat_devdocs||[]).push([[4009],{1570:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"devdocs/concurrency considerations","title":"concurrency considerations","description":"This article will describe Ocean Chat\'s thinking on high concurrency and concurrency conflicts.","source":"@site/docs/devdocs/concurrency considerations.md","sourceDirName":"devdocs","slug":"/devdocs/concurrency considerations","permalink":"/ocean.chat.docs/zh-CN/docs/devdocs/concurrency considerations","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"cache issues","permalink":"/ocean.chat.docs/zh-CN/docs/devdocs/cache issues"},"next":{"title":"file structure","permalink":"/ocean.chat.docs/zh-CN/docs/devdocs/file structure"}}');var r=s(4848),t=s(8453);const o={},c="High Concurrency",a={},l=[{value:"Architecture &amp; Scalability",id:"architecture--scalability",level:2},{value:"Connection Management &amp; Real-time",id:"connection-management--real-time",level:2},{value:"Message Persistence",id:"message-persistence",level:2},{value:"Performance &amp; Resource Management (Node.js Specifics)",id:"performance--resource-management-nodejs-specifics",level:2}];function d(e){const n={a:"a",admonition:"admonition",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"This article will describe Ocean Chat's thinking on high concurrency and concurrency conflicts."})})}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"high-concurrency",children:"High Concurrency"})}),"\n",(0,r.jsx)(n.h2,{id:"architecture--scalability",children:"Architecture & Scalability"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Stateless vs. Stateful Servers:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Stateless: Each server instance can handle any user request. This makes horizontal scaling easier (just add more servers), I need a seperate machanism(like Redis) to manage(like login state) state."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Stateful: Each server holds the state for the users connected to it. This can be simpler initially but makes scaling more complex (e.g., using sticky sessions with a load balancer(like nginx), managing state replication or handoff if a server dies). For 200k connections, stateless is often preferred."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"I decide to use redis server for state sharing."})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Load Balancing:"})}),"\n",(0,r.jsx)(n.p,{children:"I am goging to use nginx, which provides strategies like round-robin, least connections and so on."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Horizontal Scaling:"})}),"\n",(0,r.jsx)(n.p,{children:"This involves load balancing and potentially a way for instances to communicate (e.g., via nats Pub/Sub or another message bus) for cross-instance actions like group messaging."}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Now I am going to use nats as coommunicator among instances. Specifically leveraging its JetStream capabilities, for my inter-service communication."})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"TODO: Compare the advantages and disadvantages of NATS, Kafka, GRPC and Redis as intermediate servers."})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Node.js Clustering:"})}),"\n",(0,r.jsx)(n.p,{children:"Utilize Node.js's built-in cluster module to run multiple instances of my application on a single multi-core machine, effectively leveraging all CPU cores. This is crucial for Node.js performance."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"connection-management--real-time",children:"Connection Management & Real-time"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"WebSocket Library Choice:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"In first phase: I am going to use js library like ws(performant WebSocket library) manage connection."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"In next phase: I am going to use C library manage connection."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"message-persistence",children:"Message Persistence"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Message Fan-out Strategy:"})}),"\n",(0,r.jsx)(n.p,{children:"This is CRITICAL for group chats. When one user sends a message to a group of 1000 members, how should I efficiently deliver it to all currently connected members?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Pub/Sub: A common pattern is to use a fast message broker like Nats Pub/Sub. The sending server publishes the message to a group-specific channel, and all server instances subscribed to that channel receive it and forward it to their local connected clients belonging to that group. This decouples servers and scales better."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Naive Loop: Iterating and sending individually is inefficient and slow."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"I am going to use nats Pub/Sub method deliver message."})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Database Choice:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Message Storage: Needs to handle high write volumes."}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"I am going to use MongoDB."})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Session/Presence Store: Needs to be very fast for lookups (e.g., which server is user X connected to? Is user Y online?)."}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"I am going to use Redis."})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)("u",{children:"Message Queues (Optional but Recommended):"})})}),"\n",(0,r.jsx)(n.p,{children:"For tasks that don't need immediate synchronous processing (e.g., generating push notifications, archiving messages, running analytics), use a message queue (like RabbitMQ, Kafka, or cloud provider queues) to decouple services and improve resilience. Use Node.js app pushes tasks to the queue, and separate worker processes handle them."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance--resource-management-nodejs-specifics",children:"Performance & Resource Management (Node.js Specifics)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Event Loop Blocking:"})}),"\n",(0,r.jsx)(n.p,{children:"I am extremely careful not to block the Node.js event loop with synchronous or CPU-intensive operations (complex calculations, synchronous I/O, bad regex)."}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Pptional tools to detect event loop blocking:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nodejs.org/api/perf_hooks.html",children:"perf_hooks"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://nodejs.org/en/learn/getting-started/profiling",children:"Node.js Built-in Profiler (node --prof)"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://nodejs.org/en/learn/getting-started/debugging",children:"Node.js Inspector (node --inspect or node --inspect-brk)"}),':  The Performance tab in Chrome DevTools is extremely powerful. It can record activity while application is under load. Look at the "Main" thread timeline for long, solid yellow blocks labeled "Scripting".']}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://clinicjs.org/",children:"clinic.js"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://guangzhengli.com/blog/zh/indie-hacker-tech-stack-2024#%E7%BD%91%E7%AB%99%E5%88%86%E6%9E%90",children:"APM (Application Performance Management) & Monitoring Systems"})}),"\n"]})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Memory Management:"}),"\nMonitor memory usage closely. Large numbers of connections, large message payloads, or inefficient data handling can lead to memory leaks or high garbage collection overhead. Use tools like ",(0,r.jsx)(n.a,{href:"https://nodejs.org/en/learn/diagnostics/memory/using-heap-snapshot",children:"heapdump"})," and ",(0,r.jsx)(n.a,{href:"https://nodejs.org/en/learn/getting-started/profiling",children:"Node.js profilers"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous Operations:"}),"\nEmbrace async/await and Promises correctly. Ensure all I/O is non-blocking."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h1,{id:"concurrency-conflicts",children:"Concurrency Conflicts"}),"\n",(0,r.jsx)(n.p,{children:"Because transactions in MongoDB consume a lot of performance. So I am not going to use transactions to solve concurrency conflicts."}),"\n",(0,r.jsx)(n.p,{children:"I default the last change to the effective change(Last Write Wins), but this leads to lost updates:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Admin 1 reads group members. Admin 2 reads group members (same list)."}),"\n",(0,r.jsx)(n.li,{children:"Admin 1 decides to remove User X and prepares the update."}),"\n",(0,r.jsx)(n.li,{children:"Admin 2 decides to promote User Y to co-admin and prepares the update (based on the original member list)."}),"\n",(0,r.jsx)(n.li,{children:"Admin 1 writes (User X removed)."}),"\n",(0,r.jsx)(n.li,{children:"Admin 2 writes later (User Y promoted, but based on the old list, potentially overwriting the removal of User X if the entire member list is replaced)."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Result: User X might still be in the group (Admin 1's update lost), or User Y's promotion might be based on stale data."}),"\n",(0,r.jsx)(n.p,{children:"So I just allow one admin change the page, For example, if I find adminA in this interface, it will prompt adminB that the current interface is being operated by adminA, and you cannot modify the settings, you can only query."}),"\n",(0,r.jsx)(n.p,{children:"I extended the above mentioned strategy to session, only one session is allowed to operate on the same content at the same time. So there will be no concurrent conflicts between the same users."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);