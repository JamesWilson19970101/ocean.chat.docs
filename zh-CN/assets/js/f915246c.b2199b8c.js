"use strict";(self.webpackChunkoceanchat_devdocs=self.webpackChunkoceanchat_devdocs||[]).push([[2405],{784:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"devdocs/concurrency considerations","title":"\u5e76\u53d1\u95ee\u9898\u7684\u8003\u8651","description":"This article will describe Ocean Chat\'s thinking on high concurrency and concurrency conflicts.","source":"@site/i18n/zh-CN/docusaurus-plugin-content-docs/current/devdocs/concurrency considerations.md","sourceDirName":"devdocs","slug":"/devdocs/concurrency considerations","permalink":"/ocean.chat.docs/zh-CN/docs/devdocs/concurrency considerations","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"\u7f13\u5b58","permalink":"/ocean.chat.docs/zh-CN/docs/devdocs/cache"},"next":{"title":"\u5206\u5e03\u5f0f\u76f8\u5173\u95ee\u9898","permalink":"/ocean.chat.docs/zh-CN/docs/devdocs/distributed"}}');var t=s(4848),o=s(8453);const r={},c="\u5e76\u53d1\u95ee\u9898\u7684\u8003\u8651",a={},l=[{value:"Architecture &amp; Scalability",id:"architecture--scalability",level:2},{value:"Connection Management &amp; Real-time",id:"connection-management--real-time",level:2},{value:"Message Persistence",id:"message-persistence",level:2},{value:"Performance &amp; Resource Management (Node.js Specifics)",id:"performance--resource-management-nodejs-specifics",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"\u5e76\u53d1\u95ee\u9898\u7684\u8003\u8651",children:"\u5e76\u53d1\u95ee\u9898\u7684\u8003\u8651"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"This article will describe Ocean Chat's thinking on high concurrency and concurrency conflicts."})})}),"\n",(0,t.jsx)(n.h2,{id:"architecture--scalability",children:"Architecture & Scalability"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Stateless vs. Stateful Servers:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Stateless: With the exception of the connection gateway, all core business services (e.g., ",(0,t.jsx)(n.code,{children:"oceanchat-auth"}),", ",(0,t.jsx)(n.code,{children:"oceanchat-message"}),") are designed to be stateless. This means any service instance can handle any user's request, making it easy to scale horizontally by simply adding more servers. Service state (like user login sessions) is managed externally and centrally by Redis."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Stateful: The ",(0,t.jsx)(n.code,{children:"oceanchat-ws-gateway"})," (Connection Gateway) is the only stateful service in the system. Each instance must maintain the state of the WebSocket connections established with it. To support its scalability, we employ the following strategies:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State Decoupling"}),": The gateway itself only maintains connection state (e.g., ",(0,t.jsx)(n.code,{children:"connectionId"}),"), while the user's business state (e.g., ",(0,t.jsx)(n.code,{children:"userId"}),", presence status) is stored in Redis, making it accessible to all services."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Discovery"}),": A mapping between a ",(0,t.jsx)(n.code,{children:"userId"})," and the ",(0,t.jsx)(n.code,{children:"gatewayId"})," of the instance they are connected to is maintained in Redis. This allows other services (like ",(0,t.jsx)(n.code,{children:"oceanchat-pusher-realtime"}),") to accurately locate the user's gateway instance for pushing messages."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"I've decided to use Redis as the global mechanism for state storage and sharing, effectively decoupling the stateful gateway from the stateless business services."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Load Balancing:"})}),"\n",(0,t.jsx)(n.p,{children:"I am goging to use nginx, which provides strategies like round-robin, least connections and so on."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Horizontal Scaling:"})}),"\n",(0,t.jsx)(n.p,{children:"This involves load balancing and potentially a way for instances to communicate (e.g., via nats Pub/Sub or another message bus) for cross-instance actions like group messaging."}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"Now I am going to use nats as coommunicator among instances. Specifically leveraging its JetStream capabilities, for my inter-service communication."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Node.js Clustering:"})}),"\n",(0,t.jsx)(n.p,{children:"Utilize Node.js's built-in cluster module to run multiple instances of my application on a single multi-core machine, effectively leveraging all CPU cores. This is crucial for Node.js performance."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"connection-management--real-time",children:"Connection Management & Real-time"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"WebSocket Library Choice:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"In first phase: I am going to use js library like ws(performant WebSocket library) manage connection."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"In next phase: I am going to use C library manage connection."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"message-persistence",children:"Message Persistence"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Message Fan-out Strategy:"})}),"\n",(0,t.jsx)(n.p,{children:"This is CRITICAL for group chats. When one user sends a message to a group of 1000 members, how should I efficiently deliver it to all currently connected members?"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Pub/Sub: A common pattern is to use a fast message broker like Nats Pub/Sub. The sending server publishes the message to a group-specific channel, and all server instances subscribed to that channel receive it and forward it to their local connected clients belonging to that group. This decouples servers and scales better."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Naive Loop: Iterating and sending individually is inefficient and slow."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"I am going to use nats Pub/Sub method deliver message."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Database Choice:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Message Storage: Needs to handle high write volumes."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"I am going to use MongoDB."})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Session/Presence Store: Needs to be very fast for lookups (e.g., which server is user X connected to? Is user Y online?)."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"I am going to use Redis."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)("u",{children:"Message Queues (Optional but Recommended):"})})}),"\n",(0,t.jsx)(n.p,{children:"For tasks that don't need immediate synchronous processing (e.g., generating push notifications, archiving messages, running analytics), use a message queue NATS([Why did I choose NATS?](./message queue.md)) to decouple services and improve resilience. Use Node.js app pushes tasks to the queue, and separate worker processes handle them."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance--resource-management-nodejs-specifics",children:"Performance & Resource Management (Node.js Specifics)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Event Loop Blocking:"})}),"\n",(0,t.jsx)(n.p,{children:"I am extremely careful not to block the Node.js event loop with synchronous or CPU-intensive operations (complex calculations, synchronous I/O, bad regex)."}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Pptional tools to detect event loop blocking:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://nodejs.org/api/perf_hooks.html",children:"perf_hooks"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://nodejs.org/en/learn/getting-started/profiling",children:"Node.js Built-in Profiler (node --prof)"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://nodejs.org/en/learn/getting-started/debugging",children:"Node.js Inspector (node --inspect or node --inspect-brk)"}),':  The Performance tab in Chrome DevTools is extremely powerful. It can record activity while application is under load. Look at the "Main" thread timeline for long, solid yellow blocks labeled "Scripting".']}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://clinicjs.org/",children:"clinic.js"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://guangzhengli.com/blog/zh/indie-hacker-tech-stack-2024#%E7%BD%91%E7%AB%99%E5%88%86%E6%9E%90",children:"APM (Application Performance Management) & Monitoring Systems"})}),"\n"]})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Memory Management:"}),"\nMonitor memory usage closely. Large numbers of connections, large message payloads, or inefficient data handling can lead to memory leaks or high garbage collection overhead. Use tools like ",(0,t.jsx)(n.a,{href:"https://nodejs.org/en/learn/diagnostics/memory/using-heap-snapshot",children:"heapdump"})," and ",(0,t.jsx)(n.a,{href:"https://nodejs.org/en/learn/getting-started/profiling",children:"Node.js profilers"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Asynchronous Operations:"}),"\nEmbrace async/await and Promises correctly. Ensure all I/O is non-blocking."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"concurrency-conflicts",children:"Concurrency Conflicts"}),"\n",(0,t.jsx)(n.p,{children:"Because transactions in MongoDB consume a lot of performance. So I am not going to use transactions to solve concurrency conflicts."}),"\n",(0,t.jsx)(n.p,{children:"I default the last change to the effective change(Last Write Wins), but this leads to lost updates:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Admin 1 reads group members. Admin 2 reads group members (same list)."}),"\n",(0,t.jsx)(n.li,{children:"Admin 1 decides to remove User X and prepares the update."}),"\n",(0,t.jsx)(n.li,{children:"Admin 2 decides to promote User Y to co-admin and prepares the update (based on the original member list)."}),"\n",(0,t.jsx)(n.li,{children:"Admin 1 writes (User X removed)."}),"\n",(0,t.jsx)(n.li,{children:"Admin 2 writes later (User Y promoted, but based on the old list, potentially overwriting the removal of User X if the entire member list is replaced)."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Result: User X might still be in the group (Admin 1's update lost), or User Y's promotion might be based on stale data."}),"\n",(0,t.jsx)(n.p,{children:"So I just allow one admin change the page, For example, if I find adminA in this interface, it will prompt adminB that the current interface is being operated by adminA, and you cannot modify the settings, you can only query."}),"\n",(0,t.jsx)(n.p,{children:"I extended the above mentioned strategy to session, only one session is allowed to operate on the same content at the same time. So there will be no concurrent conflicts between the same users."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var i=s(6540);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);